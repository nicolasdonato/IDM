package ArduinoML.textGen;

/*Generated by MPS */

import jetbrains.mps.textGen.SNodeTextGen;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class Sketch_TextGen extends SNodeTextGen {
  public void doGenerateText(SNode node) {
    this.appendNewLine();
    this.append("void setup() {");
    this.increaseDepth();
    for (SNode component : ListSequence.fromList(SLinkOperations.getTargets(node, "components", true))) {
      this.appendNewLine();
      this.append("    pinMode(");
      this.append(String.valueOf(SPropertyOperations.getInteger(component, "pin")));
      this.append(", ");
      {
        SNode component_IN = component;
        if (SNodeOperations.isInstanceOf(component_IN, "ArduinoML.structure.Component_IN")) {
          this.append("INPUT");
        }
      }
      {
        SNode component_OUT = component;
        if (SNodeOperations.isInstanceOf(component_OUT, "ArduinoML.structure.Component_OUT")) {
          this.append("OUTPUT");
        }
      }
      this.append(");");
    }
    this.decreaseDepth();
    this.appendNewLine();
    this.append("}");
    this.appendNewLine();
    this.appendNewLine();
    this.append("void loop() {");
    this.increaseDepth();
    for (SNode signal : ListSequence.fromList(SLinkOperations.getTargets(node, "signaux", true))) {
      this.appendNewLine();
      this.append("    if (");
      if ("analogic".equalsIgnoreCase(SPropertyOperations.getString_def(signal, "type", "analogic"))) {
        this.append("analogicRead");
      } else if ("digital".equalsIgnoreCase(SPropertyOperations.getString_def(signal, "type", "analogic"))) {
        this.append("digitalRead");
      }
      this.append("(");
      this.append(String.valueOf(SPropertyOperations.getInteger(SLinkOperations.getTarget(signal, "component", false), "pin")));
      this.append(")");
      if (SPropertyOperations.getString(SLinkOperations.getTarget(signal, "transition", false), "operator") != null && !(SPropertyOperations.getString(SLinkOperations.getTarget(signal, "transition", false), "operator").equalsIgnoreCase(""))) {
        this.append(" ");
        this.append(SPropertyOperations.getString(SLinkOperations.getTarget(signal, "transition", false), "operator"));
        this.append(" ");
      } else {
        this.append(" == ");
      }
      this.append(SPropertyOperations.getString(SLinkOperations.getTarget(signal, "transition", false), "value"));
      this.append(") {");
      this.appendNewLine();
      this.append("        ");
      if ("analogic".equalsIgnoreCase(SPropertyOperations.getString_def(signal, "type", "analogic"))) {
        this.append("analogicWrite");
      } else if ("digital".equalsIgnoreCase(SPropertyOperations.getString_def(signal, "type", "analogic"))) {
        this.append("digitalWrite");
      }
      this.append("(");
      this.append(String.valueOf(SPropertyOperations.getInteger(SLinkOperations.getTarget(SLinkOperations.getTarget(signal, "transition", false), "component", false), "pin")));
      this.append(", ");
      this.append(SPropertyOperations.getString(SLinkOperations.getTarget(SLinkOperations.getTarget(signal, "transition", false), "machineStates", false), "value"));
      this.append(");");
      this.appendNewLine();
      this.append("    }");
    }
    this.decreaseDepth();
    this.appendNewLine();
    this.append("}");
  }

  public String getExtension(SNode node) {
    return "txt";
  }

  @Override
  public String getFilename(SNode node) {
    return SPropertyOperations.getString(node, "name");
  }
}
